<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WDK LAB 바텀업 스코어카드 v1.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .skeleton { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 50% { opacity: .5; } }
        .rank-gold { background-color: #fffbeb; color: #b45309; }
        .rank-silver { background-color: #f8fafc; color: #475569; }
        .rank-bronze { background-color: #fdf8f6; color: #92400e; }
        .score-positive { color: #16a34a; }
        .score-negative { color: #dc2626; }
        .score-neutral { color: #64748b; }
    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-slate-900 dark:text-white">WDK LAB 바텀업 스코어카드</h1>
            <p class="text-slate-500 dark:text-slate-400 mt-2">최정예 빅테크 요원 선발 시스템</p>
            <div class="mt-4 space-x-4">
                <a href="./index.html" class="text-indigo-500 hover:text-indigo-600 transition-colors">🏠 홈으로</a>
                <a href="./dashboard_topdown.html" class="text-emerald-500 hover:text-emerald-600 transition-colors">← 탑다운 대시보드로 돌아가기</a>
                <a href="./guide_bottomup.html" class="text-blue-500 hover:text-blue-600 transition-colors">스코어카드 행동강령 보기 →</a>
            </div>
        </header>

        <section id="scoreboard">
            <div class="bg-white dark:bg-slate-800 rounded-2xl shadow-lg p-6">
                <div class="overflow-x-auto">
                    <table class="w-full text-sm text-left">
                        <thead class="text-xs text-slate-700 dark:text-slate-400 uppercase bg-slate-50 dark:bg-slate-700">
                            <tr>
                                <th class="px-4 py-3">순위</th>
                                <th class="px-4 py-3">종목</th>
                                <th class="px-4 py-3 text-center">모멘텀 (40%)</th>
                                <th class="px-4 py-3 text-center">펀더멘탈 (40%)</th>
                                <th class="px-4 py-3 text-center">밸류에이션 (20%)</th>
                                <th class="px-4 py-3 text-center">최종 점수</th>
                            </tr>
                        </thead>
                        <tbody id="scoreboard-body">
                            </tbody>
                    </table>
                </div>
                 <p class="text-xs text-slate-400 mt-4 text-right">Last Updated: <span id="last-updated">-</span></p>
            </div>
        </section>
    </div>

<script>
// =================================================================================
// 문제의 원인이었던 프록시 주소를, 이미 잘 쓰고 계신 구글 프록시 주소로 바꿨습니다.
// =================================================================================
const PROXY_URL = 'https://asia-northeast3-my-dashboard-proxy.cloudfunctions.net/fredProxy';

const TICKERS = ['NVDA', 'MSFT', 'AAPL', 'GOOGL', 'AMZN', 'META', 'TSLA'];

const scoreboardBody = document.getElementById('scoreboard-body');
const lastUpdatedEl = document.getElementById('last-updated');
const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

function showLoadingState() {
    let skeletonHTML = '';
    TICKERS.forEach(ticker => {
        skeletonHTML += `
            <tr class="border-b dark:border-slate-700">
                <td class="px-4 py-4"><div class="h-4 w-4 bg-slate-200 dark:bg-slate-700 rounded skeleton"></div></td>
                <td class="px-4 py-4 font-bold"><div class="h-4 w-16 bg-slate-200 dark:bg-slate-700 rounded skeleton"></div></td>
                <td class="px-4 py-4 text-center"><div class="h-4 w-12 mx-auto bg-slate-200 dark:bg-slate-700 rounded skeleton"></div></td>
                <td class="px-4 py-4 text-center"><div class="h-4 w-12 mx-auto bg-slate-200 dark:bg-slate-700 rounded skeleton"></div></td>
                <td class="px-4 py-4 text-center"><div class="h-4 w-12 mx-auto bg-slate-200 dark:bg-slate-700 rounded skeleton"></div></td>
                <td class="px-4 py-4 text-center"><div class="h-4 w-12 mx-auto bg-slate-200 dark:bg-slate-700 rounded skeleton"></div></td>
            </tr>
        `;
    });
    scoreboardBody.innerHTML = skeletonHTML;
}

async function fetchTickerData(ticker, retries = 2) {
    // 프록시 서버가 finviz.com 주소를 받아서 대신 접속하도록 URL 구조를 바꿨습니다.
    const finvizUrl = `https://finviz.com/quote.ashx?t=${ticker}`;
    const requestUrl = `${PROXY_URL}?url=${encodeURIComponent(finvizUrl)}`;
    
    for (let i = 0; i <= retries; i++) {
        try {
            const response = await fetch(requestUrl);
            if (!response.ok) throw new Error(`Proxy fetch failed: ${response.status}`);
            
            // 구글 프록시는 바로 HTML 텍스트를 보내주므로, JSON 파싱 과정이 필요 없습니다.
            const htmlText = await response.text();

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, 'text/html');
            
            const data = {};
            const table = doc.querySelector('.snapshot-table2');
            if (!table) throw new Error('Data table not found on Finviz page');

            const cells = table.querySelectorAll('td');
            for (let j = 0; j < cells.length; j += 2) {
                const key = cells[j].textContent.trim();
                const value = cells[j + 1].textContent.trim();
                data[key] = value;
            }
            return { ticker, data }; // 성공

        } catch (error) {
            console.warn(`Attempt ${i + 1} for ${ticker} failed:`, error);
            if (i === retries) return { ticker, error: error.message }; // 최종 실패
            await sleep(1000);
        }
    }
}

function calculateScores(tickerData) {
    const data = tickerData.data;
    if (!data) return { ...tickerData, scores: null, finalScore: -Infinity };

    const parseFloatOrNull = (str) => {
        if (typeof str !== 'string' || str === '-') return null;
        return parseFloat(str.replace('%', ''));
    };

    let momentumScore = 0;
    const rsi = parseFloatOrNull(data['RSI (14)']);
    const isAboveSMA200 = data['SMA200']?.includes('Above');
    const isBelowSMA200 = data['SMA200']?.includes('Below');
    if (rsi !== null) {
        if (rsi >= 50 && isAboveSMA200) momentumScore = 1;
        else if (rsi < 50 && isBelowSMA200) momentumScore = -1;
    }

    let fundamentalScore = 0;
    const salesGrowthQQ = parseFloatOrNull(data['Sales Q/Q']);
    const epsGrowthQQ = parseFloatOrNull(data['EPS Q/Q']);
    if (salesGrowthQQ !== null && epsGrowthQQ !== null) {
        if (salesGrowthQQ >= 15 && epsGrowthQQ >= 15) fundamentalScore = 1;
        else if (salesGrowthQQ < 0 || epsGrowthQQ < 0) fundamentalScore = -1;
    }

    let valuationScore = 0;
    const forwardPE = parseFloatOrNull(data['Forward P/E']);
    const pastPE = parseFloatOrNull(data['P/E']);
    if (forwardPE !== null && pastPE !== null && pastPE > 0) {
        if (forwardPE < pastPE * 0.9) valuationScore = 1;
        else if (forwardPE > pastPE * 1.2) valuationScore = -1;
    }
    
    const scores = { momentum: momentumScore, fundamental: fundamentalScore, valuation: valuationScore };
    const finalScore = (scores.momentum * 0.4) + (scores.fundamental * 0.4) + (scores.valuation * 0.2);
    return { ...tickerData, scores, finalScore };
}

function renderScoreboard(results) {
    const allFailed = results.every(r => r.error);
    if (results.length === 0 || allFailed) {
        scoreboardBody.innerHTML = `
            <tr>
                <td colspan="6" class="px-4 py-10 text-center text-red-500 font-semibold">
                    ❗️ 외부 데이터 로딩에 실패했습니다.<br>
                    잠시 후 페이지를 새로고침(F5) 해주세요.
                </td>
            </tr>
        `;
        lastUpdatedEl.textContent = 'Error';
        return;
    }

    results.sort((a, b) => b.finalScore - a.finalScore);

    let tableHTML = '';
    results.forEach((result, index) => {
        const rank = index + 1;
        let rankClass = '';
        if (rank === 1) rankClass = 'rank-gold';
        else if (rank === 2) rankClass = 'rank-silver';
        else if (rank === 3) rankClass = 'rank-bronze';

        const getScoreHTML = (score) => {
            let scoreClass = 'score-neutral';
            if (score > 0) scoreClass = 'score-positive';
            else if (score < 0) scoreClass = 'score-negative';
            return `<span class="font-bold ${scoreClass}">${score}</span>`;
        };
        
        const getFinalScoreHTML = (score) => {
             let scoreClass = 'text-slate-500';
            if (score > 0) scoreClass = 'score-positive';
            else if (score < 0) scoreClass = 'score-negative';
            return `<span class="font-bold text-lg ${scoreClass}">${score.toFixed(2)}</span>`;
        }

        tableHTML += `<tr class="border-b dark:border-slate-700 ${rankClass}">
            <td class="px-4 py-4 font-bold text-lg">${rank}</td>
            <td class="px-4 py-4 font-bold text-slate-900 dark:text-slate-100">${result.ticker}</td>`;

        if (result.error || !result.scores) {
            tableHTML += `<td colspan="4" class="px-4 py-4 text-center text-red-500">데이터 로딩 실패: ${result.error || 'N/A'}</td>`;
        } else {
            tableHTML += `
                <td class="px-4 py-4 text-center">${getScoreHTML(result.scores.momentum)}</td>
                <td class="px-4 py-4 text-center">${getScoreHTML(result.scores.fundamental)}</td>
                <td class="px-4 py-4 text-center">${getScoreHTML(result.scores.valuation)}</td>
                <td class="px-4 py-4 text-center">${getFinalScoreHTML(result.finalScore)}</td>`;
        }
        tableHTML += `</tr>`;
    });

    scoreboardBody.innerHTML = tableHTML;
    lastUpdatedEl.textContent = new Date().toLocaleString('ko-KR');
}

async function main() {
    showLoadingState();
    // 여러 데이터를 동시에 병렬로 불러와서 로딩 속도를 개선했습니다.
    const fetchPromises = TICKERS.map(ticker => fetchTickerData(ticker));
    const rawResults = await Promise.all(fetchPromises);
    const scoredResults = rawResults.map(result => calculateScores(result));
    renderScoreboard(scoredResults);
}

document.addEventListener('DOMContentLoaded', main);

</script>
</body>
</html>
